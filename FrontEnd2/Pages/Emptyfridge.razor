@page "/Emptyfridge"
@using Newtonsoft.Json;
@inject HttpClient Http
@using FrontEnd2.Data;
@using System.Text;
@using System.Globalization;
@using BBCollection.BBObjects;
@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject AuthenticationFunctionallity uf

<div class="col-sm stackComponents">
    <button type="button" class="btn-success" @onclick="(() => Search())"> Find Recipe </button>
</div>
<h3>@testvalue</h3>

@code {
    string testvalue;
    ShoppinlistFunctionality ListFunc = new ShoppinlistFunctionality("api/Storage");
    HttpResponseMessage responseMessage = new HttpResponseMessage();
    List<WeightedRecipies> recpies = new List<WeightedRecipies>();
    List<Recipe> _recpies = new List<Recipe>();
    String email;
    String userId;
    private delegate bool compareWR(WeightedRecipies r1, WeightedRecipies r2);
    //public delegate int PerformCalculation(int x, int y);

    protected async override Task OnInitializedAsync()
    {
        userId = email;
        responseMessage = await ListFunc.GetProductsOnStart(userId);



        ;
    }

    private async Task<List<WeightedRecipies>> FindValidRecipies(List<Product> storageInventory)
    {
        //await Search();
        List<Recipe> ValidRecipies = new List<Recipe>();
        bool breakFlag;
        List<Product> tester = new List<Product>() { new Product("1", "rødvin", "full", 1d, "image", "lidl"),new Product("1", "bacon", "full", 1d, "image", "lidl") };
        //string id, string productName, string amount, double price, string image, string storeName
        foreach (Recipe r in _recpies)
        {
            breakFlag = false;
            //foreach (Product p in storageInventory)
            foreach (Product p in tester)
            {
                foreach (Ingredient i in r._ingredientList)
                {
                    if (compareIngrdientAndProduct(i, p))//kan godt være man bliver nødtil at lave en eller anden form for kryds referance
                    {
                        ValidRecipies.Add(r);
                        breakFlag = true;
                        break;
                    }
                }
                if (breakFlag)
                {
                    break;
                }
            }

        }

        return GenerateWeightedRecepies(ValidRecipies, storageInventory); ;
    }

    private List<WeightedRecipies> GenerateWeightedRecepies(List<Recipe> recipes, List<Product> storageInventory)
    {
        List<Product> tester = new List<Product>() { new Product("1", "rødvin", "full", 1d, "image", "lidl"),new Product("1", "bacon", "full", 1d, "image", "lidl")  };
        List<WeightedRecipies> returnRecipies = new List<WeightedRecipies>();
        foreach (Recipe r in recipes)
        {
            returnRecipies.Add(new WeightedRecipies(r));
        }

        foreach (WeightedRecipies w in returnRecipies)
        {
            //foreach (Product p in storageInventory)
            foreach (Product p in tester)
            {
                foreach (Ingredient i in w._recipie._ingredientList)
                {
                    if (compareIngrdientAndProduct(i, p))
                    {
                        w.MatchFound(i);
                    }
                }

            }
        }
        return returnRecipies;
    }

    private bool compareIngrdientAndProduct(Ingredient ingrdient, Product product)
    {
        //return product._productName.Contains(ingrdient._IngredientName);
        return ingrdient._IngredientName.Contains(product._productName);
    }

    protected async Task Search()
    {
        string printRecipe;

        printRecipe = await Http.GetStringAsync("https://localhost:44325/api/recipe?recipeTitle=" + " ");
        _recpies = JsonConvert.DeserializeObject<List<Recipe>>(printRecipe);

        compareWR test1 = new compareWR(CompareComplexity);
        compareWR test2 = new compareWR(CompareMatches);

        //recpies = Sort(FindValidRecipies(ListFunc.itemList).Result, test1);
        recpies = FindValidRecipies(ListFunc.itemList).Result;
        foreach (WeightedRecipies wr in recpies)
        {
            if (wr.matchingIngrdientsNum > 1) 
            {
                testvalue =testvalue + wr._recipie._Name + " ? ";
            }
            
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await GetLocalSession();
            localStorage.Changed += (sender, e) =>
            {
                Console.WriteLine($"Value for key {e.Key} changed from {e.OldValue} to {e.NewValue}");
            };

            //if (email != null)
            //{
            //    gottenData = await Http.GetStringAsync("https://localhost:44325/api/Login/" + email + "S");
            //}
            StateHasChanged();
        }

    }

    async Task GetLocalSession()
    {
        email = await localStorage.GetItemAsync<string>("Email");
    }

    public class WeightedRecipies
    {
        public Recipe _recipie { get; set; }
        public int complexity { get; set; }
        public int matchingIngrdientsNum { get; set; }
        public List<Ingredient> matchingIngrdient = new List<Ingredient>();

        public WeightedRecipies(Recipe _recipie)
        {
            this._recipie = _recipie;
            complexity = _recipie._ingredientList.Count();
        }

        public void MatchFound(Ingredient ingrdient)
        {
            matchingIngrdient.Add(ingrdient);
            Console.WriteLine("yeet");
            matchingIngrdientsNum = matchingIngrdient.Count();
        }
    }

    private static bool CompareComplexity(WeightedRecipies r1, WeightedRecipies r2)
    {
        return r1.complexity > r2.complexity;
    }

    private static bool CompareMatches(WeightedRecipies r1, WeightedRecipies r2)
    {
        return r1.matchingIngrdientsNum > r2.matchingIngrdientsNum;
    }

    private static List<WeightedRecipies> Sort(List<WeightedRecipies> recipies, compareWR CompareWR)
    {
        WeightedRecipies[] arr = recipies.ToArray();

        int i, j;
        WeightedRecipies temp;
        bool swapped;
        for (i = 0; i < arr.Length - 1; i++)
        {
            swapped = false;
            for (j = 0; j < arr.Length - i - 1; j++)
            {
                if (CompareWR(arr[j], arr[j + 1]))
                {
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }

            if (swapped == false)
                break;
        }

        return arr.ToList();
    }
}
