@using BBCollection.BBObjects;
@using BBCollection.DBConncetion;
@using BBCollection.DBHandling;
@using Newtonsoft.Json;
@using FrontEnd2.Data;
@using BBCollection.Queries;
@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject HttpClient Http

@if (email != null)
{
    <Row>
        <Column>
            <Card Margin="Margin.Is4.FromTop">
                <CardHeader Padding="Padding.Is1.FromBottom" Style="position:fixed">
                    <Heading Size="HeadingSize.Is4">My Storage</Heading>
                </CardHeader>
            </Card>
            <CardBody Padding="Padding.Is0.FromBottom">
                <Fields>
                    <Column ColumnSize="ColumnSize.Is1">
                        <CheckEdit Checked="@user.shoppinglist.Products.All(x=>x._completed)" CheckedChanged="user.shoppinglist.CheckAll">All</CheckEdit>
                    </Column>
                    <Column ColumnSize="ColumnSize.Is11">
                        <Addons>
                            <Addon AddonType="AddonType.Body">
                                <Validations @ref="validations" Mode="ValidationMode.Manual">
                                    <Validation Validator="@ValidationRule.IsNotEmpty">
                                        <TextEdit @bind-Text="@name" Placeholder="Add a new product"></TextEdit>
                                    </Validation>
                                </Validations>
                            </Addon>
                            <Addon AddonType="AddonType.End">
                                <Button Color="Color.Primary" Clicked="@addProductName">
                                    <Icon Name="IconName.New" />Add
                                </Button>
                            </Addon>
                        </Addons>
                    </Column>
                </Fields>
            </CardBody>
            <CardBody Padding="Padding.Is0.OnY">

                <ListGroup IsFlush="true" Class="text-center">
                    @foreach (Product p in user.storage.storageList)
                    {
                        <StorageItem Product="@p" StatusChanged="@OnStatusChanged"></StorageItem>
                    }

                </ListGroup>
            </CardBody>
            <CardFooter Class="card-footerShoppinglist" Padding="Padding.Is3.FromBottom">
                <Field IsHorizontal="true">
                    <FieldBody ColumnSize="ColumnSize.Is10">
                        <Buttons Role="ButtonsRole.Addons">
                            <Button Color="Color.Info" Clicked="@(() => user.shoppinglist.SetFilter(UserShoppinglist.Filter.All))" IsActive="@(user.shoppinglist.filter == UserShoppinglist.Filter.All)"><Icon Name="@(FontAwesomeIcons.Save)" /></Button>
                            <Button Color="Color.Info" Clicked="@(() => user.shoppinglist.ClearItems())" IsActive="@(user.shoppinglist.filter == UserShoppinglist.Filter.Completed)"><Icon Name="@(FontAwesomeIcons.Trash)" /></Button>
                            <Button Color="Color.Info" Clicked="@(() => user.shoppinglist.SetFilter(UserShoppinglist.Filter.Completed))" IsActive="@(user.shoppinglist.filter == UserShoppinglist.Filter.Completed)"> ??</Button>
                        </Buttons>
                        <Text Class="shoppinglist-Price-Text"> Total  @String.Format("{0:0.0}", user.shoppinglist.CompletePrice()) DKK</Text>
                    </FieldBody>
                    <FieldBody ColumnSize="ColumnSize.Is2">
                        <Button Color="Color.Warning" Float="Float.Right" Visibility="@(user.shoppinglist.Products.Any(x=>x._completed) ? Visibility.Always : Visibility.Never)"><Icon Name="@(FontAwesomeIcons.Archive)" /></Button>
                    </FieldBody>
                </Field>
            </CardFooter>
        </Column>
    </Row>


    <Accordion>
        <Modal @ref="recipeRef">
            <ModalBackdrop />
            <ModalContent IsCentered="true" Size="ModalSize.Large">
                <ModalHeader>
                    <ModalTitle Size="1"> @recipeName </ModalTitle>
                    <CloseButton Clicked="hideModal" />
                </ModalHeader>
                <Card>
                    <CardHeader>
                        <Heading Size="HeadingSize.Is5" Class="text-center">
                            <Button Clicked="@(()=>isOpen1 = !isOpen1)">Description</Button>
                        </Heading>
                    </CardHeader>
                    <Collapse IsOpen="@isOpen1">
                        <CardBody>
                            <p style="text-align:center; padding: 4px 7px 2px 4px;"> @recipeDescription </p>
                        </CardBody>
                    </Collapse>
                </Card>
                <Card>
                    <CardHeader>
                        <Heading Size="HeadingSize.Is5" Class="text-center">
                            <Button Clicked="@(()=>isOpen2 = !isOpen2)" Style="font-weight:bold">Ingrediens</Button>
                        </Heading>
                    </CardHeader>
                    <Collapse IsOpen="@isOpen2">
                        <CardBody>
                            <div class="input-group mb-3">
                                <div class="input-group-prepend">
                                    <label class="input-group-text" for="inputGroupSelect01"> For:</label>
                                </div>
                                <SelectEdit TValue="int" SelectedValue="selectedValue" SelectedValueChanged="@OnSelectedValueChanged" Style="max-width:100px;">
                                    @{
                                        int numb = 0;
                                        @for (int i = 0; i < 99; i++)
                                        {
                                            <SelectItem Value="TempScalar">@(++numb)</SelectItem>
                                        }
                                    }
                                </SelectEdit>
                            </div>
                            <Table Theme="Theme.Light" IsStriped="false" IsHoverable="true" IsFullWidth="true" IsBorderless="true">
                                <TableHeader>
                                    <TableRow>
                                        <TableHeaderCell></TableHeaderCell>
                                        <Tooltip IsAlwaysActive="true" Text="Click on an ingredient to find a product">
                                            <TableHeaderCell></TableHeaderCell>
                                        </Tooltip>
                                    </TableRow>
                                </TableHeader>
                                <TableBody>
                                    @foreach (Ingredient ing in ingredients)
                                    {
                                        <TableRow>
                                            @if (runCounter <= ingredients.Count) //comback and fix
                                            {
                                                runCounter++;
                                                scalar = recipePerPerson;
                                            }
                                            <TableRowCell Style="width:50px">@(String.Format("{0:0.0}", (ing._amount / recipePerPerson) * scalar)) @ing._unit</TableRowCell>
                                            @if (ingrdientDict.ContainsKey(ing))
                                            {
                                                <TableRowCell Style="width:150px">
                                                    <Button Class="btn btn-block btn-success" @onclick="(() => retriveIngredient(ing))"><Icon Padding="Padding.Is1.FromTop" Float="Float.Left" Name="@(FontAwesomeIcons.CheckCircle)"></Icon> @ing._ingredientName</Button>
                                                </TableRowCell>
                                            }
                                            else if (InshoppingList.Contains(ing))
                                            {
                                                <TableRowCell Style="width:150px">
                                                    <Button Color="Color.Success" IsOutline="true" Class="btn btn-block btn-light" @onclick="(() => retriveIngredient(ing))"><Icon Padding="Padding.Is1.FromTop" Float="Float.Left" Name="@(FontAwesomeIcons.ShoppingCart)"></Icon>@ing._ingredientName</Button>
                                                </TableRowCell>
                                            }
                                            else
                                            {
                                                <TableRowCell Style="width:150px">
                                                    <Button Class="btn btn-block btn-light" @onclick="(() => retriveIngredient(ing))"><Icon Padding="Padding.Is1.FromTop" Float="Float.Left" Name="@(FontAwesomeIcons.CartPlus)"></Icon>@ing._ingredientName</Button>
                                                </TableRowCell>
                                            }

                                        </TableRow>
                                    }
                                </TableBody>
                            </Table>
                        </CardBody>
                    </Collapse>
                </Card>
                <Card>
                    <CardHeader>
                        <Heading Size="HeadingSize.Is5" Class="text-center">
                            <Button Clicked="@(()=>isOpen3 = !isOpen3)" Style="font-weight:bold">Products</Button>
                        </Heading>
                    </CardHeader>
                    <Collapse IsOpen="@isOpen3">
                        <CardBody>
                            @if (products.Count == 0)
                            {
                                <p> Choose an ingredient</p>
                            }
                            else
                            {
                                @foreach (Product p in products)
                                {
                                    <Table Theme="Theme.Light" IsBordered="true">
                                        <TableBody>
                                            <TableRowHeader Style="width:5%"><Button Class="btn btn-block btn-outline-success" Clicked="()=>AddProductToSL(p)"> <Icon Name="@(FontAwesomeIcons.ShoppingCart)"></Icon></Button> </TableRowHeader>
                                            <TableRowCell Style="width:25%">@p._price Kr.</TableRowCell>
                                            <TableRowCell Style="width:70%">@p._productName</TableRowCell>
                                        </TableBody>
                                    </Table>
                                }
                            }
                        </CardBody>
                    </Collapse>
                </Card>
            </ModalContent>
        </Modal>
    </Accordion>

    @if (_viewLoadMore)
    {
        <div class="row mt-4 d-flex justify-content-center">
            <button class="btn btn-warning mb-5 mx-auto" @onclick="()=>LoadMoreRecepies()">Load More</button>
        </div>
    }
}


@code {
    #region Fields
    private string name;
    private string searchBox;
    object selectedSearchValue { get; set; }

    private void addProductName()
    {
        if (validations.ValidateAll())
        {
            products.Add(new Product { _productName = name });
            name = null;

            validations.ClearAll();
        }
    }



    List<Product> itemList = new List<Product>();
    private Validations validations;
    ConnectionSettings connectionSettings = new ConnectionSettings();
    private Modal recipeRef;
    string email, userId, recipeDescription, recipeName;
    string tempState;
    string TempScalar;
    string tempIngredientName;
    string shopString;
    string replacementUlr = "https://cdn.discordapp.com/attachments/519096261408718908/649685312083197973/coopdicoop.jpg";
    List<List<string>> AllProductRefs;
    int ID;

    int recipePerPerson;
    int LoadingBarProggres;
    int selectedValue;
    int value;
    int x;
    int scalar;
    int runCounter = 0;
    int Timesload = 0;
    int defualtAmountLoad = 10;
    int NewAmount;

    bool found = true;
    bool viewTitle = false;
    bool viewIngredients = false;
    bool viewProducts = false;
    bool FlagYeet = true;
    bool isOpen1 = true;
    bool isOpen2 = true;
    bool isOpen3 = true;
    bool disableButton = false;
    bool changeState = false;
    bool _viewLoadMore = false;
    bool IngrdientIsCurrentlySelected = false;
    bool _viewEmptyFridgeLoadSpinner = false;
    bool loadingbar = false;
    bool _showFilters = false;
    bool pmatch = true;
    bool OverallMatch = false;
    bool _FoodBiskEnabled = false;

    //ShoppinlistFunctionality ListFunc = new ShoppinlistFunctionality("api/Storage");
    UserData user;
    HttpResponseMessage responseMessage = new HttpResponseMessage();
    Product tempProduct = new Product();
    Ingredient currentlySelectedIngredient;
    List<Ingredient> InshoppingList = new List<Ingredient>();

    List<float> recipeAmount = new List<float>();
    List<Ingredient> ingredients = new List<Ingredient>();
    List<WeightedRecipies> recpies = new List<WeightedRecipies>();
    List<WeightedRecipies> Allrecpies = new List<WeightedRecipies>();
    List<Recipe> _recpies = new List<Recipe>();
    List<Product> products = new List<Product>();
    List<Product> ToShoppinglist = new List<Product>();
    Recipe selectedRecepie = new Recipe();
    List<string> ItemState = new List<string>() { "Full", "Almost Full", "Half Full", "Almost Empty" };
    ControllerFuncionality features = new ControllerFuncionality();
    Dictionary<Ingredient, List<string>> ingrdientDict = new Dictionary<Ingredient, List<string>>();
    Dictionary<Product, bool> SelectedProducts = new Dictionary<Product, bool>();
    //ShoppinlistFunctionality ShopList = new ShoppinlistFunctionality("api/Shoppinglist");

    private delegate bool compareWR(WeightedRecipies r1, WeightedRecipies r2);
    #endregion

    #region StorageMethods

    public bool StorageExists()
    {
        return user.storage.storageList.Count > 0;
    }

    /// <summary>
    /// The state of an item is changed.
    /// </summary>
    /// <param name="item">The item of which the state shouold be changes</param>
    /// <param name="state">The state to chaneg to</param>
    public async Task ChangeProductState(Product p, string state)
    {
        // Finds the index of the input item
        p._state = state;

        // Change the state in the storage list
        //await ListFunc.ChangeItemInStorage(ListFunc.CombinedList[index]);
        await user.storage.EditProduct(p);
    }

    public async Task DeleteProduct(Product p)
    {
        await user.storage.DeleteProduct(p);
        StateHasChanged();
    }


    /// <summary>
    /// This method changes the amount of an item.
    /// If there is only one left, it is deleted.
    /// Else the amount left is decremented.
    /// </summary>
    /// <param name="item"></param>
    public async Task ChangeItemAmout(Product p)
    {
        await user.storage.DeleteProduct(p, 1);
        StateHasChanged();
    }
    #endregion

    #region OnInit_async_Method

    /// <summary>
    /// If it is the first render, the email is requested form the local storage.
    /// From this email, the storage from the user will be requested from the api.
    /// </summary>
    /// <param name="firstRender"></param>
    /// <returns></returns>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await GetLocalSession();

            if (email != null)
            {
                user = new UserData(email);
                await user.storage.Get();
            }
            intailizeAllProducts(user.storage.storageList);
            StateHasChanged();
        }

    }

    async Task GetLocalSession()
    {
        // The email is requested fomr localstorage
        email = await localStorage.GetItemAsync<string>("Email");
    }
    #endregion

    #region Recipe_Display_Methods
    void matchNotFound()
    {
        found = true;
    }

    void matchFound()
    {
        found = false;
    }
    void Found()
    {
        found = true;
    }

    void clear()
    {
        ingredients.Clear();
        recipeAmount.Clear();
    }

    void closeRecipies()
    {
        _viewLoadMore = false;
        viewTitle = !viewTitle;
    }

    void retriveInfo(WeightedRecipies rep)
    {
        //Recipe show = _recpies.First(x => x._recipeID == ID);
        ingrdientDict = rep.ingrdients;
        selectedRecepie = rep._recipie;
        recipeName = rep._recipie._Name;
        recipeDescription = rep._recipie._description;
        ingredients = rep._recipie._ingredientList;
        recipePerPerson = (int)rep._recipie._PerPerson;
        selectedValue = recipePerPerson;
        found = true;
        showModal();
        viewIngredients = true;
        //viewAddToshoppinglist = true;
    }

    void incrementRecipeAmount()
    {
        for (int i = 0; i < recipeAmount.Count; i++)
        {
            found = true;
            if (recipeAmount[i] != 0)
            {
                recipeAmount[i] = (recipeAmount[i] / recipePerPerson) * (recipePerPerson + 1F);
                value++;
            }
        }
        recipePerPerson += 1;
    }


    void decrementRecipeAmount()
    {
        if (recipePerPerson >= 2)
        {
            for (int i = 0; i < recipeAmount.Count; i++)
            {
                found = true;
                if (recipeAmount[i] != 0)
                {
                    recipeAmount[i] = (recipeAmount[i] / recipePerPerson) * (recipePerPerson - 1F);
                    value--;
                }
            }
            recipePerPerson -= 1;
        }
    }
    #endregion

    #region empty fridge

    private async Task FindRecipies()
    {
        _viewEmptyFridgeLoadSpinner = true;
        int HasBeenLoaded = 0;
        this.StateHasChanged();
        EmptyFridgeFuntionality emptyFridgeFuntionality = new EmptyFridgeFuntionality(CreateCurrentSelctedList());
        Allrecpies = await emptyFridgeFuntionality.GetWeightedRecipies();
        LoadMoreRecepies();
        loadingbar = true;
        LoadingManager(++HasBeenLoaded, user.storage.storageList.Count);
        this.StateHasChanged();

        viewTitle = true;
        _viewEmptyFridgeLoadSpinner = false;
        _viewLoadMore = true;
        await disableLoad();
    }
    private void LoadingManager(int currentLoad, int TotalToLoad)
    {
        LoadingBarProggres = currentLoad == TotalToLoad ? 100 : ((int)(100 * ((float)currentLoad / (float)TotalToLoad)));
    }
    private async Task disableLoad()
    {
        await Task.Delay(3000);
        loadingbar = false;
    }

    private async Task<List<Recipe>> getRecepies()
    {
        _recpies = JsonConvert.DeserializeObject<List<Recipe>>(await Http.GetStringAsync("https://localhost:44325/api/recipe?recipeTitle=" + " "));
        List<Recipe> recepies = _recpies;
        return recepies;
    }

    #endregion

    private async Task AssignScalar(ChangeEventArgs e, Product p)
    {
        await ChangeProductState(p, e.Value.ToString());
    }

    private void showModal()
    {
        recipeRef.Show();
    }

    private void hideModal()
    {
        recipeRef.Hide();
    }

    private void OnSelectedValueChanged(int value)
    {
        selectedValue = value;
        scalar = selectedValue;
    }

    private void retriveIngredient(Ingredient ID)
    {
        currentlySelectedIngredient = ID;
        viewProducts = true;
        Ingredient ing = ingredients.First(x => x._ingredientName == ID._ingredientName);
        tempIngredientName = ing._ingredientName;
        retriveProduct();
    }

    private async void retriveProduct()
    {
        if (products != null)
        {
            products.Clear();
        }
        products.AddRange(await Products(tempIngredientName));
        this.StateHasChanged();
    }

    private async Task<List<Product>> Products(string ingredient)
    {
        List<Product> resProducts = new List<Product>();
        ProductHandling productHandling = new ProductHandling();
        resProducts = await productHandling.GetListAsync(ingredient);
        if (resProducts.Count == 0)
        {
            resProducts = await SlowExsperimentalSearch(ingredient);
        }
        resProducts.Sort((a, b) => a._price.CompareTo(b._price));

        return resProducts;
    }

    private async Task<List<Product>> SlowExsperimentalSearch(string searchterm)
    {
        string[] InduviduelTerms = searchterm.Split(" ");
        ProductHandling pTest = new ProductHandling();
        List<List<Product>> TempListList = new List<List<Product>>();
        List<Product> ProductList = new List<Product>();

        foreach (string s in InduviduelTerms)
        {
            TempListList.Add(await pTest.ReferencesAsync(s));
        }
        TempListList = TempListList.OrderByDescending(x => -x.Count).ToList();
        if (ProductList.Count == 0)
        {
            foreach (List<Product> Plist in TempListList)
            {
                if (Plist.Count != 0)
                {
                    ProductList = Plist;
                    break;
                }
            }
        }
        foreach (Product p in ProductList)
        {
            p._CustomReferenceField = "*";
        }
        return ProductList;
    }

    public async void AddProductToSL(Product AddedItem)
    {
        disableButton = true;
        StateHasChanged();
        InshoppingList.Add(currentlySelectedIngredient);
        AddedItem._amountleft++;

        int actualAmout = AddedItem._amountleft;

        AddedItem._amountleft = 1;

        AddedItem._image = features.SetOnePicture(AddedItem._image);

        if (String.IsNullOrEmpty(email))
        {
            await GetAndSetLocalStorage(AddedItem);
        }
        else
        {
            await user.shoppinglist.AddProduct(AddedItem);
        }

        AddedItem._amountleft = actualAmout;

        disableButton = await AwaitButton();
        StateHasChanged();
    }

    public async Task GetAndSetLocalStorage(Product product)
    {
        ToShoppinglist = await GetLocalStorage();

        ToShoppinglist.Add(product);

        ToShoppinglist = features.HandleDublicats(ToShoppinglist);

        await localStorage.RemoveItemAsync("ProductString");

        shopString = JsonConvert.SerializeObject(ToShoppinglist);

        await localStorage.SetItemAsync("ProductString", shopString);
    }

    public async Task<bool> AwaitButton()
    {
        await Task.Delay(40);
        return false;
    }

    public async Task<List<Product>> GetLocalStorage()
    {
        shopString = await localStorage.GetItemAsync<string>("ProductString");

        if (!String.IsNullOrEmpty(shopString))
        {
            return JsonConvert.DeserializeObject<List<Product>>(shopString);
        }

        return new List<Product>();
    }

    public void LoadMoreRecepies()
    {
        Timesload++;
        NewAmount = defualtAmountLoad * Timesload;
        if (!(Allrecpies.Count >= NewAmount))
        {
            NewAmount = Allrecpies.Count % NewAmount;
            _viewLoadMore = false;
        }

        recpies = Allrecpies.GetRange(0, NewAmount);
    }

    public void toggelFilters()
    {
        _showFilters = !_showFilters;
    }

    //public void SortRecepies()
    //{
    //    if (pmatch)
    //    {
    //        recpies = Allrecpies.OrderByDescending(x => -x.pMatch).ToList().GetRange(0,defualtAmountLoad * Timesload);

    //    }
    //    else if (OverallMatch)
    //    {
    //        recpies = Allrecpies.OrderByDescending(x => -x.matchingIngrdientsNum).ToList().GetRange(0,defualtAmountLoad * Timesload);
    //    }
    //    StateHasChanged();
    //}

    public void SortPmatch()
    {
        recpies = Allrecpies.OrderByDescending(x => x.pMatch).ToList().GetRange(0, NewAmount);
        StateHasChanged();
    }

    public void SortOverallMatch()
    {
        recpies = Allrecpies.OrderByDescending(x => x.matchingIngrdientsNum).ToList().GetRange(0, NewAmount);
        StateHasChanged();
    }
    public void CheckIfAnySelected()
    {
        List<Product> returnList = new List<Product>();
        foreach (Product key in SelectedProducts.Keys)
        {
            if (SelectedProducts[key])
            {
                returnList.Add(key);
            }
        }

        _FoodBiskEnabled = returnList.Count != 0 ? true : false;
    }

    public void intailizeAllProducts(List<Product> products)
    {
        foreach (Product product in products)
        {
            SelectedProducts.Add(product, false);
        }
    }

    public List<Product> CreateCurrentSelctedList()
    {
        List<Product> returnList = new List<Product>();
        foreach (Product key in SelectedProducts.Keys)
        {
            if (SelectedProducts[key])
            {
                returnList.Add(key);
            }
        }

        return returnList;
    }

    //public void updateSelectedProducts(Product product)
    //{
    //    SelectedProducts[product] = Toggelbool(SelectedProducts[product]);
    //    CheckIfAnySelected();
    //}

    //public bool Toggelbool(bool _bool)
    //{
    //    return !_bool;
    //}

    //public void SortPmatch()
    //{
    //    recpies = Allrecpies.OrderByDescending(x => x.pMatch).ToList().GetRange(0, NewAmount);
    //    StateHasChanged();
    //}

    //public void SortOverallMatch()
    //{
    //    recpies = Allrecpies.OrderByDescending(x => x.matchingIngrdientsNum).ToList().GetRange(0, NewAmount);
    //    StateHasChanged();
    //}
    //public void CheckIfAnySelected()
    //{
    //    List<Product> returnList = new List<Product>();
    //    foreach (Product key in SelectedProducts.Keys)
    //    {
    //        if (SelectedProducts[key])
    //        {
    //            returnList.Add(key);
    //        }
    //    }

    //    _FoodBiskEnabled = returnList.Count != 0 ? true : false;
    //}

    //public void intailizeAllProducts(List<Product> products)
    //{
    //    foreach (Product product in products)
    //    {
    //        SelectedProducts.Add(product, false);
    //    }
    //}

    //public List<Product> CreateCurrentSelctedList()
    //{
    //    List<Product> returnList = new List<Product>();
    //    foreach (Product key in SelectedProducts.Keys)
    //    {
    //        if (SelectedProducts[key])
    //        {
    //            returnList.Add(key);
    //        }
    //    }

    //    return returnList;
    //}

    //public void updateSelectedProducts(Product product)
    //{
    //    SelectedProducts[product] = Toggelbool(SelectedProducts[product]);
    //    CheckIfAnySelected();
    //}

    //public bool Toggelbool(bool _bool)
    //{
    //    return !_bool;
    //}

    public void OnStatusChanged(bool isChecked)
    {
        StateHasChanged();
    }
}